;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(doc reduce)" "(doc assoc)" "(doc condp)" "(doc comp)" "clear" "(ns user)" "(doc reduce)" "(ns core)" "(doc reduce)" "(docs reduce)" "(doc reduce)" "(ns user)" "(slurp filename)" "(doc condp)" "(ns user)" "exit" "(my-first \"a\")" "(my-first [0 1])" "(ns four-clojure.core)" "(my-first [0 1])" "(my-first [\"a\" \"b\" \"c\"])" "(ns four-clojure)" "(doc str)" "(doc map)" "(ns user)" "(doc reduce)" "(doc map)" "(doc str)" "(ns four-clojure)" "(and 0 1)" "(and false true)" "(or 1 1)" "(or 1 0)" "(or 0 1)" "(or 0 0)" "(or true true)" "(or true false)" "(or false true)" "(or false false)" "(or - +)" "(or + -)" "(reduce inc 0 [1 2 3 4])" "(reduce (fn [c %] (inc c)) 0 [1 2 3 4])" "(reduce (fn [c ] (inc c)) 0 [1 2 3 4])" "(reduce (fn [c _] (inc c)) 0 [1 2 3 4])" "(test 0 2)" "(test 0 0)" "(test 0)" "(defn test [c _] (inc c))" "(fn [c _] (inc c))" "(fn [c _] (inc c)) 0" "(map (inc 1) [1 2 3])" "(map (fn [x] 1) [1 2 3])" "(map (fn [x] 1) %) [1 2 3]" "#(map (fn [x] 1) %) [1 2 3]" "(map (fn [x] 1) %) [1 2 3]" "((map (fn [x] 1) %) [1 2 3])" "#(reduce + (map (fn [x] 1) %)) [1 2 3 4]" "#(reduce + (map (fn [x] 1) %)) [1234]" "(reduce + (map (fn [x] 1)) [8 2 3 3 1])" "(reduce (fn [a b] (inc b)) [8 2 3 3 1])" "(reduce (fn [a b] (count)) [8 2 3 3 1])" "(reduce (fn [a b] (count a)) [8 2 3 3 1])" "(reduce (fn [a b] (inc a)) [8 2 3 3 1])" "(reduce (fn [a b] (inc a)) [1 2 3 3 1])" "(reduce (fn [a b] (inc 0)) [1 2 3 3 1])" "(reduce (fn [a] (print a)) [1 2 3 3 1])" "(reduce (fn [a b] (print a)) [1 2 3 3 1])" "(reduce (fn [a b] (print  b)) [1 2 3 3 1])" "(reduce (fn [a b] (print a b)) [1 2 3 3 1])" "(reduce + [1 2 3 3 1])" "(reduce (fn [x] (str \"hello\")) [1 2 3 3 1])" "(reduce (fn [x] (0)) [1 2 3 3 1])" "(reduce 1 [1 2 3 3 1])" "clear" "(fn [] (fn [x] (inc 1)) [1 2 3 3 1])" "(reduce (fn [x] (inc 1)) [1 2 3 3 1])" "(reduce (fn [] (inc 1)) [1 2 3 3 1])" "(reduce (inc 1) [1 2 3 3 1])" "(reducetions + '(1 2 3 4))" "(inc 
   (inc 
      (inc 0 1) 2) 3)" "(inc [1 2 3])" "(inc 0)" "(reduce inc 0 '(1 2 3))" "(reduce + 0 '(1 2 3))" "(reduce (inc) [1 2 3 3 1])" "(reduce (inc 0 %) [1 2 3 3 1])" "(reduce (inc 0) [1 2 3 3 1])" "(reduce + 0 [1 2 3 3 1])" "clear" "(reduce inc 0 [1 2 3 3 1])" "(reduce inc [1 2 3 3 1])" "(reduce inc '(1 2 3 3 1))" "(reduce inc 0 '(1 2 3 3 1))" "((fn [x] (for [i x :let [s (+ % 1)]] s)) 0 '(1 2 3 3 1))" "((fn [x] (for [i x :let [s (+ 0  1)]] s)) '(1 2 3 3 1))" "((fn [x (def count 0)] (for [i x :let [s (+ count  1)]] s)) '(1 2 3 3 1))" "((fn [x] (for [i x :let [s (+ s 1)]] s)) '(1 2 3 3 1))" "((fn [x] (for [i x :let [s (+ 1 1)]] s)) '(1 2 3 3 1))" "((fn [x]) (for [i x :let [s (+ 1 1)]] s) '(1 2 3 3 1))" "((fn [x] (for [i x :let [s (+ 1 1)] s]  '(1 2 3 3 1))))" "((fn [x 0] ((def count 0) (for [i x :let [s (+ count 1)] s]) ) '(1 2 3 3 1)))" "((fn [x 0] ((def count 0) (for [i x (+ count 1)]) ) '(1 2 3 3 1)))" "((fn [x] (for [i x :let [s (+ s 1)]] s )) '(1 2 3 3 1))" "((fn [x] (for [i x :let [s (+ i 1)]] s )) '(1 2 3 3 1))" "((fn [x, y]  (drop y x) ) '(4 5 6 7) 2)" "((fn [x, y]  ( (drop y x)) ) '(4 5 6 7) 2)" "((fn [x, y]  (first (drop y x)) ) '(4 5 6 7) 2)" "((fn [x, y] (take y x) ) '(4 5 6 7) 2)" "(fn [x, y] (take y x) ) '(4 5 6 7) 2)" "((fn [x, y] (take y x) ) '(4 5 6 7) 2) 6)
false" "( ((fn [x, y] (take y x) ) '(4 5 6 7) 2))" "(= ((fn [x, y] (take y x) ) '(4 5 6 7) 2) 6)" "(= (nth '(4 5 6 7) 2) 6)" "(nth '([1 2] [3 4] [5 6]) 2)" "(nth [1 2 3 4] 1)" "(nth '(4 5 6 7) 2)" "(nth [1 2 3 4] 2)" "(take-nth 2 [0 1 2 3])" "(zipmap [:a :b :c] [0 0 0])" "(into map [0] [:a :b :c])" "(assoc [0] [:a :b :c])" "(into [0] [:a :b :c])" "(into 0 [:a :b :c])" "(assoc 0 [:a :b :c])" "(zipmap 0 [:a :b :c])" "(add 0 [:a :b :c])" "(apply 0 [:a :b :c])" "(into 0 [:a :b :c])" "(assoc 0 [:a :b :c])" "(conj 0 [:a :b :c])" "(hash-map 0 [:a :b :c])" "(map 0 [:a :b :c])" "(map [:a :b] [:foo :bar])" "(get [:a :b] [:foo :bar])" "(+ [:a :b] [:foo :bar])" "(= [:a :b] [:foo :bar])" "(__ [:a :b] [:foo :bar])" "(= ([0 0] 0 [:a :b :c]) {:a 0 :b 0 :c 0})" "(= ([0 0 0] 0 [:a :b :c]) {:a 0 :b 0 :c 0})" "(= (0 0 0 [:a :b :c]) {:a 0 :b 0 :c 0})" "(= (2 1 0 [:a :b :c]) {:a 0 :b 0 :c 0})" "((:foo {:bar 0, :baz 1} 2) :foo)" "(:foo (:foo {:bar 0, :baz 1} 2))" "( (:foo {:bar 0, :baz 1} 2))" "(let [[a b c d e] [0 1 2 3 4]] [x y])" "(if-not nil 1 0)" "(if-not false 1 0)" "(= '(1 5 9 13 17 21 25 29 33 37) (for [x (range 40)
            :when (= 1 (rem x 4))]
        x))" "(= (1 5 9 13 17 21 25 29 33 37) (for [x (range 40)
            :when (= 1 (rem x 4))]
        x))" "(= '(1 5 9 13 17 21 25 29 33 37) (for [x (range 40)
            :when (= 1 (rem x 4))]
        x))" "(range 1 40 4)" "(for [[x y] (partition 2 (range 20))]
        (+ x y))" "(for [x (iterate #(+ 4 %) 0)
            :let [z (inc x)]
            :while (< z 40)]
        z)" "(for [x (range 40) :when (= 1 (rem x 4))] x)" "(+ 1 2)" "(+ 3 4)" "(doc use)" "(doc require)" "(doc refer)" "(cider-turn-on-eldoc-mode)" "(ns clojure-noob.core)" "(+ 2 3)" "(ns clojure-noob.core)" "(ns user)" "(quote (1 1 1))" "(quote (1 2 3))" "(quote 1 2 3)" "'(1 2 3)" "(list 1 2 3)" "(1 2 3)" "(doc partial)" "(doc swap!)" "(doc foo)" "(doc if)" "(doc doc)" "(use 'clojure.repl)" "(doc foo)" "(doc if)" "*clojure-version*" "(ns playground.core)" "(for-test 1)" "(for-test 3)" "clear" "#'chapter-3.core/-main" "(+ 3 2)" "@(bounce.core/ask :!app)" "@(bc/ask :!app)" "(js/alert \"hello world\")" "(bounce.figwheel/cljs-repl (bounce.core/ask :cljs-compiler))" "(bounce.core/reload!)" "(bounce-core/reload!)" "(+ 2 3)" "(dissoc {:first \"hello\", :last \"world\"} :last)" "(assoc {:first \"hello\"} :last \"world\")" "(+ 2/3 4/2)" "(- 1 2 3 4)" "(/ 5 2)" "(reduce + 15 [1 2 3 4])" "(re-find #\"^left-\" \"12left-eye\")" "(re-find #\"left-\" \"12left-eye\")" "(re-find #\"left-\" \"left-eye\")" "(re-find #\"^left-\" \"left-eye\")" "(train)" "(-main)" "(square 7)" "(use 'training-day)" "(square 7)" "(use 'training-day)" "(square 10)" "(defn square [x] (* x x))" "(train)" "(* 2 3)" "(* 2 2)" "clear" "(* 1 3)" "clear" "(+ 2 2)" "clear" "(+ 1 2)" "(map)" "(println \"Cleanliness is next to godliness\")" "(reduce + [5 6 100])" "(map inc [1 2 3 4])" "(+ 1 2 3 4)" "(or false nil \"venti\" \"why\")" "(or false nil :large_I_mean_venti :why_cant_I_just_say_large)" "(= \"abc\" \"abc\")" "(+ 2 3)" "clear" "+ 1 * 5 + 4 5)) 3 4 5)" "(+ 1 (* 2 4) 3 4 5)" "q" "(map)" "(-main)" "(train)" "(-main)" "(reduce + [5 6 100])" "(map inc [1 2 3 4])" "(+ 1 2 3 4)")