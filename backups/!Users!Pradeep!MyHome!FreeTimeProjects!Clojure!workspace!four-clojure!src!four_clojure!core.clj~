(ns four-clojure.core)

(defn foo
  "I don't do a whole lot."
  [x]
  (println x "Hello, World!"))

(+ 2 3)

;; Maps
(defn error-message
  [severity]
  (str "OH whatever!!"
    (if (= severity :mild)
      "convinced"
      "doomed")))

(:a {:a "a" :b "b" :c "c"})

(:d {:a "a" :b "b" :c "c"} "Default Value")

;; Vectors
[0 1 2]

(get [0 1 2] 1)

(get [1 {"name" "value"} "string"] 2)

(vector "a" 1 2/3)

(conj [0 1 2 3] 4)

;; Lists
'(1 2)

;; Lists doesn't support get method instead use nth
(nth '(1 2 3) 1)

;; nth to retrieve an element from a list is slower than using get to retrieve an element from a vector. This is because Clojure has to traverse all n elements of a list to get to the nth, whereas it only takes a few hops at most to access a vector element by its index

;; list values can be heterogeneous similar to other data structures
(list "a" 0 {:a "a"})

;; conj function adds elements to the begining of the list

(conj '(1 2 3) 4)

;; Sets - A collection of unique values
;; 2 kinds of sets hash-sets and sorted-sets

#{1 "a" :a}

(hash-set 1 1 2 2)

(conj #{:a :b} :a)

(conj #{:a :b} :c)

(set [0 1 2])
(set '(0 1 2))

(set [0 0 1 1 1 2 2 2])
(set '(0 0 1 1 1 2 2 2))

(contains? #{"a" "b" "c"} "a")
(contains? #{"a" "b" "c"} "A")
(contains? #{nil} nil)

(:a #{:a :b})

(get #{:a :b} :a)
(get #{:a :b} :c)
;; The following is option of using get to test if the value is nil is not right. Its better to use contains? instead.
(get #{:a nil} nil)

(inc 1)

(map inc [1 2 3])

(+ 1 2 3)

(defn my-first
  [[first-thing]] ; Notice that first-thing is within a vector
  first-thing)

(my-first [0 1])
